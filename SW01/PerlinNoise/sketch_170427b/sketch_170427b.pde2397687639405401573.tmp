void setup() {
  size(800, 800);
  background(255);
  stroke(0);
  for (int i = 0; i<64; i++) {
    perlin(2134, 13.5, 1);
  }
}

public float perlin(float pointX, float pointY, int dimension) {  
  float myPointX = pointX%dimension;
  float myPointY = pointY%dimension;
  PVector myPoint = new PVector(myPointX, myPointY);
  int x0=0;
  int x1=dimension;
  int y0=0;
  int y1=dimension;


  PVector gradientVectorBottomLeft, gradientVectorBottomRight, 
    gradientVectorTopRight, gradientVectorTopLeft;

  gradientVectorBottomLeft = new PVector(randomGradientVector(dimension), randomGradientVector(dimension));
  gradientVectorBottomRight = new PVector(randomGradientVector(dimension), randomGradientVector(dimension));
  gradientVectorTopRight = new PVector(randomGradientVector(dimension), randomGradientVector(dimension));
  gradientVectorTopLeft = new PVector(randomGradientVector(dimension), randomGradientVector(dimension));

  PVector distanceVectorBottomLeft, distanceVectorBottomRight, 
    distanceVectorTopRight, distanceVectorTopLeft;

  distanceVectorBottomLeft= myPoint.sub(x0, y0);
  distanceVectorBottomRight= myPoint.sub(x1, y0);
  distanceVectorTopRight= myPoint.sub(x1, y1);
  distanceVectorTopLeft= myPoint.sub(x0, y1);

  float influenceValueBottomLeft = gradientVectorBottomLeft.x * distanceVectorBottomLeft.x+
    gradientVectorBottomLeft.y * distanceVectorBottomLeft.y;
  float influenceValueBottomRight= gradientVectorBottomRight.x * distanceVectorBottomRight.x+
    gradientVectorBottomRight.y * distanceVectorBottomRight.y;
  float influenceValueTopRight=    gradientVectorTopRight.x * distanceVectorTopRight.x+
    gradientVectorTopRight.y * distanceVectorTopRight.y;
  float influenceValueTopLeft=     gradientVectorTopLeft.x * distanceVectorTopLeft.x+
    gradientVectorTopLeft.y * distanceVectorTopLeft.y;

  // Below are 4 influence values in the arrangement:
  // [g1] | [g2]
  // -----------
  // [g3] | [g4]
  float g1, g2, g3, g4;
  g1=g2=g3=g4=0;
  // These coordinates are the location of the input coordinate in its unit square.  
  // For example a value of (0.5,0.5) is in the exact center of its unit square.

  float x1Lerp = lerp(g1, g2, myPointX);
  float x2Lerp = lerp(g3, g4, myPointX);


  float average = lerp(x1Lerp, x2Lerp, myPointY);
  stroke(average);
  point(myPointX, myPointY);



  return influenceValueBottomLeft;
}


public float fade(float t) {
  // Fade function as defined by Ken Perlin.  This eases coordinate values
  // so that they will ease towards integral values.  This ends up smoothing
  // the final output.
  return t * t * t * (t * (t * 6 - 15) + 10);         // 6t^5 - 15t^4 + 10t^3
}


public int randomGradientVector(int dimension) {
  return round(random(-1*(dimension), dimension));
}


void draw() {
}